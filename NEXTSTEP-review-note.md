# 넥스트스텝 TDD, Clean Code with Java의 리뷰 템플릿과 메시지들
- 메시지를 저장해두는 이유는 다음과 같다. 
    1. 리뷰이들은 비슷한 부분을 실수하는 경우가 많다.
    2. 리뷰이들에게 정확한 메시지를 전달하기 위해서 나도 한번 더 찾아보게 되는데 이를 공부하며 기록해두기 위해서이다.

### 리플렉션을 지양해야 하는 이유
```
리플렉션은 '컴파일 시점'에서 알기 어려운 정보를 다룰때 사용되어야 된다고 생각합니다. 이외에 다른 방법이 있다면 리플렉션보다 우선되어야 한다고 봐요. 🤔
제가 생각하는 리플렉션을 지양해야 하는 이유는 크게 2가지 정도입니다.

1. 리플렉션은 코드를 읽기가 어렵습니다. 가독성이 떨어지면 결국 유지보수성도 떨어지게 되겠죠?
2. 리플렉션은 컴파일 시점에 알 수 없는 에러가 런타임 시점에서 발생되는 위험성이 있습니다.
```

### 적절한 커밋 단위에 대해서
```
제가 생각하는 이상적인 커밋단위는 '가능한' 작게 입니다. 😁
'가능한'에 기준을 어디로 잡는지가 주관적일텐데요. **님이 이번 넥스트스텝 과정을 진행하시면서 커밋단위를 최대한 작게도 해보시고, 너무 작다 싶으면 그보다는 넓은 범위로 지정해서 연습해보시면 **님만의 기준이 생길꺼라고 생각합니다.

작은 커밋단위가 주는 장점은 크게 2가지 정도가 있다고 생각해요.

1. 작업한 로그로써 가치가 있습니다. 예전 코드들을 보면서 왜 이렇게 짰을까? 많이 고민하게 되는데요. 이럴때 당시에 커밋내역들을 보면 작업이 생각이 나기도 하고, 다른 개발자들도 내역만 꼼꼼히 본다면 보다 쉽게 이해할 수 있습니다.
2. 작업을 롤백해야할때 상세히 나눈 커밋로그들은 가장 효율적인 롤백시점을 찾을 수 있다고 생각해요.

커밋단위를 나누기 위해서 해당 커밋의 type을 달주는 것도 좋습니다. (테스트 코드용 커밋인지, 기능을 구현하기 위한 커밋인지, 리팩토링용 커밋인지 한눈에 구분할수가 있어요 👍 )
자세한 사항이 궁금하시면 아래와같은 커밋 가이드를 참고해주세요!
git 커밋 스타일 가이드

제가 이상적으로 생각하는 커밋단위를 실천한다면 TDD 사이클에서 한 사이클동안 3개 이상의 커밋단위가 나오게 됩니다. (이부분은 이해가 안되시면 일단 넘어가세요 ㅎㅎ TDD는 이후에 배우게됩니다.)
```

###  미션 요청사항과 관련은 없지만 언급하고 싶은 부분이 있을때
```
이 부분은 미션 요청사항이 아닌 한번 고민해보셨으면 좋은 부분에 대한 제 개인적 생각입니다. (이미 고려하셨을 수도 있지만 혹시 아니시더라도 편하게 읽어주세요. 😄 )
```

### 요구사항을 만족하지 못했을  
```
다만 기능적 요구사항에 대해서 검토해주셨으면 하는 사항이 있어서 변경요청드렸습니다.
```

### 정규표현식 Pattern 객체를 지양해야하는 이유
```
정규표현식을 사용하면 생성비용이 높은 Pattern 인스턴스 생성됩니다. 정규표현식보다 좀 더 적절한 방법은 없는지 고민해보시면 좋겠습니다.
```

### static의 장점과 단점
```
기능을 static으로 제공하면 어떤 장점과 단점이 있을까요? 🤔
제가 생각하는 장점은 편리함입니다. 별도의 객체선언 없이 사용할수 있으니까요. (부가적으로 무의미한 객체생성을 막고 메모리를 아낄수도 있겠네요)
단점은 너무 강한 결합이라고 생각해요. 객체가 아니게되니 디자인 패턴을 적용하기도 어려워지고 결합도를 낮추는 고민을 해볼수 있는 기회가 없어집니다. 저는 static으로 제공할때는 정말로 이 강한 결합을 허용해도 될까? 고민하는 편입니다. 😁

(+ 부과설명을 드리자면 static 메서드가 non-static 메서드로 변한것만으로는 결합도의 차이를 느끼지 못하셨을 수 있습니다. non-static이 되었다는건 결합도를 낮추는 '초석'을 다진 행위입니다. 전략패턴과 같이 결합도를 낮추는 디자인 패턴을 고민해 볼 수 있는 상태가 되었다는 의미입니다. 😁)
```

### 무의미한 매직넘버 상수화
```
매직넘버를 왜 상수화 하는걸까요? 🤔
저는 의미를 알기 어려운 문자 리터럴를 알기 쉽게하기 위해서 사용하는 편입니다.
이런면에서 볼때 0를 ZERO로 상수화 할필요는 없다고 생각해요.. 🙂
```

### 객체에 책임에 대해서
```
makeManualLotto를 View가 담당하는게 적절한걸까요? 🤔

저는 객체의 책임에 대해서 생각해볼때 해당 로직(책임)에 대한 변경 요구사항을 가정해보고, 그 부분이 자연스럽게 떠오르거나 이해가 되는지 고민해봅니다. 😁

수동 로또 구입하는 로직을 수정해주세요. 라는 요구사항을 받았을때 수정하는 개발자가 View에 해당 로직이 있을거라는게 예상되는 곳 일까요? 💭💭
```

### 전략패턴 (인터페이스와 다수의 구현체)는 왜 쓰는 걸까
```
하나의 인터페이스와 여러 구현체가 가지는 장점은 무엇일까요? 🤔
저는 다형성을 통한 유연성이라고 생각합니다.

하지만 NumberGenerator를 의존하는 LottoStore는 이런 이점을 누리고 있지 못하고 있다고 생각합니다.
2개의 구현체에 대한 별개의 메서드가 각각 존재하기 때문이죠. NumberGenerator의 구현체가 하나가 더 늘어나면 LottoStore는 또다시 해당 구현체에 대한 대응 코드가 만들어져야합니다. 💭💭
```

### String + 연산
```
문자열을 붙이는 연산에서는 StringBuilder를 사용하길 권해드립니다.
String은 + 연산 이전에 문자열과 연산 이후의 연산 문자열이 각각 별개의 인스턴스로 존재합니다.
따라서 "----" 와 같은 문자열을 만드는 과정에서 ("", "-", "--", "---", "----") 5개의 인스턴스가 생기게 되어서 비효율적인 메모리 사용을 발생시킵니다.

혹시 아래 이슈들을 모르셨다면 한번 찾아보시길 권해드립니다. 😁
Q) StringBuilder, StringBuffer의 차이 (면접 단골질문이더라구요)
Q) 자바 1.5버전 이상부터는 String 연산을 컴파일러가 알아서 최적화하여 굳이 StringBuilder를 안써도 된다고 하던데...? 진짜 그럴까요? 그럼 언제 StringBuilder를 사용해야할까요?
```

### 메서드 이름은 동사
```
메서드 이름은 가능한 동사로 만들어 만들어주세요. 😄 

[자바 코딩 컨벤션](https://myeonguni.tistory.com/1596)
```

### @ParameterizedTest와 @NullAndEmptySource
```
@ParameterizedTest 와 @NullAndEmptySource 를 사용하면 하나의 단언문으로 만들수 있겠네요. 🙂
```

### 의존 방향에 대한 고민, 순환참조
```
저는 '의존'하다는 것은 의존하고 있는 객체가 변화할때 그 변화를 함께 감수하겠다. 라고 정의해요. 🙂
view가 변경될때 그 영향이 domain에 가는것은 불필요한 결합도라고 생각합니다.
```
